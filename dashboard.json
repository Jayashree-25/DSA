{
  "metadata": {
    "totalProblems": 4,
    "lastUpdated": "2025-08-29T13:44:54.787Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 4,
        "Easy": 2,
        "Medium": 1,
        "Hard": 1
      },
      "Hackerrank": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "leetcode-easy-palindrome-number",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Palindrome Number",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        int reversed = 0;\n        while (x > reversed) {\n            reversed = reversed * 10 + x % 10;\n            x = x / 10;\n        }\n        return x == reversed || x == reversed / 10;\n    }\n}",
        "readme": "Math\n\nGiven an integer x, return true if x is a palindrome, and false otherwise.\n\n \nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n \nConstraints:\n\n\n\t-231 <= x <= 231 - 1\n\n\n \nFollow up: Could you solve it without converting the integer to a string?",
        "notes": "Palindrome Number\n\n          - Summary: The function `isPalindrome` checks if an integer `x` is a palindrome. It uses no explicit data structures beyond built-in integer variables. The algorithm first handles negative numbers and numbers ending in zero (except 0). Then, it iteratively reverses the integer `x` while comparing it to the original until either the reversed number is greater than or equal to the original or the original is reduced to a single or zero digit.  Finally, it checks if the original and reversed numbers are equal or if the original number is equal to the reversed number divided by 10 to account for odd-length palindromes.\n\n          - Time Complexity: O(log10(x)) because the number of iterations in the while loop is proportional to the number of digits in x, which is logarithmic with respect to x. In each iteration, a constant number of operations are performed.\n          - Space Complexity: O(1) because the algorithm uses only a constant amount of extra space to store variables such as `reversed`, regardless of the size of the input integer x."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T13:44:54.606Z"
    },
    {
      "id": "leetcode-easy-two-sum",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Two Sum",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public static int[] twoSum(int[] nums, int target) {\n        for(int i=0; i<nums.length; i++){\n            for(int j=i+1; j<nums.length; j++){\n                if(i != j){\n                    if((nums[i] + nums[j]) == target){\n                        return new int[]{i,j};\n                    }\n                }\n            }\n        }\n        return new int[]{};\n    }\n    public static void main(String[] args){\n        int[] nums = {3,4,5,6};\n        int target = 7;\n        int[] sol = twoSum(nums, target);\n        System.out.println(sol);\n    }\n}",
        "readme": "ArrayHashTable\n\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\n \nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
        "notes": "Two Sum\n\n          - Summary: The code utilizes a single array to store input numbers. It employs nested loops to iterate through all possible pairs of numbers within the array.  For each pair, it checks if their sum equals the target value. If a pair with the target sum is found, their indices are returned; otherwise, an empty array is returned after checking all pairs.\n\n          - Time Complexity: O(n^2) because of the nested for loops, resulting in a time complexity proportional to the square of the input array's size.\n          - Space Complexity: O(1) as the algorithm uses a constant amount of extra space regardless of the input array size. The space used for storing the result array is also constant."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T13:44:54.607Z"
    },
    {
      "id": "leetcode-medium-add-two-numbers",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Add Two Numbers",
      "language": "java",
      "files": {
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        // Dummy head to make it easier to return the result\n        ListNode dummyHead = new ListNode(0);\n        ListNode current = dummyHead;\n\n        int carry = 0;\n\n        // Traverse both lists\n        while (l1 != null || l2 != null) {\n            // Get the values (0 if the node is null)\n            int x = (l1 != null) ? l1.val : 0;\n            int y = (l2 != null) ? l2.val : 0;\n\n            // Add values and carry\n            int sum = x + y + carry;\n            carry = sum / 10;\n\n            // Create a new node with the digit value\n            current.next = new ListNode(sum % 10);\n            current = current.next;\n\n            // Move to the next nodes\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n\n        // If there's a carry left, add a new node\n        if (carry > 0) {\n            current.next = new ListNode(carry);\n        }\n\n        // Return the result, skipping the dummy head\n        return dummyHead.next;\n    }\n}",
        "readme": "LinkedListMathRecursion\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \nExample 1:\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \nConstraints:\n\n\n\tThe number of nodes in each linked list is in the range [1, 100].\n\t0 <= Node.val <= 9\n\tIt is guaranteed that the list represents a number that does not have leading zeros.",
        "notes": "Add Two Numbers\n\n          - Summary: This Java code adds two numbers represented as linked lists. It uses the ListNode data structure to represent the numbers, where each node stores a digit. The algorithm iterates through both lists simultaneously, adding digits and handling carry-overs. A dummy head node simplifies the process of returning the resulting linked list.\n\n          - Time Complexity: O(max(m, n)), where m and n are the lengths of the two input linked lists. This is because the algorithm iterates through the lists once, performing constant-time operations at each step.\n          - Space Complexity: O(max(m, n)) in the worst case. This is because the resulting linked list can have a length of up to max(m, n) + 1 (to accommodate a potential carry-over).  The space used for other variables is constant."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T13:44:54.608Z"
    },
    {
      "id": "leetcode-hard-median-of-two-sorted-arrays",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Median of Two Sorted Arrays",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        int m = nums1.length;\n        int n = nums2.length;\n        int low = 0, high = m;\n\n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (m + n + 1) / 2 - partitionX;\n\n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n            int minRightX = (partitionX == m) ? Integer.MAX_VALUE : nums1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n            int minRightY = (partitionY == n) ? Integer.MAX_VALUE : nums2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                // Found the correct partition\n                if ((m + n) % 2 == 0) {\n                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n                } else {\n                    return (double)Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n        throw new IllegalArgumentException(\"Input arrays are not sorted.\");\n    }\n}",
        "readme": "ArrayBinarySearchDivideandConquer\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \nConstraints:\n\n\n\tnums1.length == m\n\tnums2.length == n\n\t0 <= m <= 1000\n\t0 <= n <= 1000\n\t1 <= m + n <= 2000\n\t-106 <= nums1[i], nums2[i] <= 106",
        "notes": "Median of Two Sorted Arrays\n\n          - Summary: This Java code efficiently finds the median of two sorted arrays using binary search. It employs arrays as the primary data structure to store input numbers. The algorithm cleverly partitions the arrays to find the middle elements, handling both even and odd total element counts.  A key logic decision involves adjusting the binary search's boundaries based on whether the current partition satisfies the median condition.\n\n          - Time Complexity: O(log(min(m, n))), where 'm' and 'n' are the lengths of the input arrays. This is because the algorithm uses binary search on the smaller array, resulting in a logarithmic time complexity.\n          - Space Complexity: O(1). The algorithm uses a constant amount of extra space to store variables, irrespective of the input array sizes."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T13:44:54.610Z"
    }
  ]
}